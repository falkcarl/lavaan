# the multivariate normal distribution, unrestricted (h1)
# - everything is evalued under the MLEs: Mu = ybar, Sigma = S 

# 1) loglikelihood h1 (from raw data, or sample statistics)
# 4) hessian h1 around MLEs
# 5) information h1 (restricted Sigma/mu)
#    5a: (unit)    expected information h1 (A1 = Gamma.NT^{-1})
#    5b: (unit)    observed information h1 (A1 = Gamma.NT^{-1})
#    5c: (unit) first.order information h1 (B1 = A1 %*% Gamma %*% A1)
# 6) inverted information h1 mu + vech(Sigma)
#    6a: (unit) inverted expected information (A1.inv = Gamma.NT)
#    6b: (unit) inverted observed information (A1.inv = Gamma.NT)
#    6c: (unit) inverted first-order information (B1.inv)
# 7) ACOV h1 mu + vech(Sigma)
#    7a: 1/N * Gamma.NT
#    7b: 1/N * Gamma.NT
#    7c: 1/N * (Gamma.NT * Gamma^{-1} * Gamma.NT)
#    7d: 1/N * Gamma (sandwich)


# YR 25 Mar 2016: first version
# YR 19 Jan 2017: added 6) + 7)

# 1. likelihood h1

# 1a: input is raw data
lav_mvnorm_h1_loglik_data <- function(Y             = NULL,
                                      casewise      = FALSE,
                                      Sinv.method   = "eigen") {
    P <- NCOL(Y); N <- NROW(Y)

    # sample statistics
    sample.mean <- colMeans(Y)
    sample.cov <- 1/N*crossprod(Y) - tcrossprod(sample.mean)

    if(casewise) {
        LOG.2PI <- log(2 * pi)

        # invert sample.cov
        if(Sinv.method == "chol") {
            cS <- chol(sample.cov); icS <- backsolve(cS, diag(P))
            Yc <- t( t(Y) - sample.mean )
            DIST <- rowSums((Yc %*% icS)^2)
            logdet <- -2 * sum(log(diag(icS)))
        } else {
            sample.cov.inv <- lav_matrix_symmetric_inverse(S = sample.cov, 
                                  logdet = TRUE, Sinv.method = Sinv.method)
            logdet <- attr(sample.cov.inv, "logdet")
            # mahalanobis distance
            Yc <- t( t(Y) - sample.mean )
            DIST <- rowSums(Yc %*% sample.cov.inv * Yc)
        }

        loglik <- -(P * LOG.2PI + logdet + DIST)/2

    } else {
        # invert sample.cov
        sample.cov.inv <- lav_matrix_symmetric_inverse(S = sample.cov,
                              logdet = TRUE, Sinv.method = Sinv.method)
        logdet <- attr(sample.cov.inv, "logdet")

        loglik <-
            lav_mvnorm_h1_loglik_samplestats(sample.cov.logdet = logdet,
                                             sample.nvar       = P,
                                             sample.nobs       = N)
    }

    loglik
}



# 1b: input are sample statistics only (logdet, N and P)
lav_mvnorm_h1_loglik_samplestats <- function(sample.cov.logdet = NULL,
                                             sample.nvar       = NULL,
                                             sample.nobs       = NULL,
                                             # or
                                             sample.cov        = NULL,
                                             Sinv.method    = "eigen") {

    if(is.null(sample.nvar)) {
        P <- NCOL(sample.cov)
    } else {
        P <- sample.nvar # number of variables
    }

    N <- sample.nobs
    stopifnot(!is.null(P), !is.null(N))

    LOG.2PI <- log(2 * pi)

    # all we need is the logdet
    if(is.null(sample.cov.logdet)) {
        sample.cov.inv <- lav_matrix_symmetric_inverse(S = sample.cov,
                              logdet = TRUE, Sinv.method = Sinv.method)
        logdet <- attr(sample.cov.inv, "logdet")
    } else {
        logdet <- sample.cov.logdet
    }

    loglik <- -N/2 * (P * LOG.2PI + logdet + P)

    loglik
}


# 4. hessian of logl (around MLEs of Mu and Sigma)

# 4a: hessian logl Mu and vech(Sigma) from raw data
lav_mvnorm_h1_logl_hessian_data <- function(Y              = NULL,
                                            Sinv.method    = "eigen",
                                            sample.cov.inv = NULL) {
    N <- NROW(Y)

    # observed information
    observed <- lav_mvnorm_h1_information_observed_data(Y = Y, 
                    Sinv.method = Sinv.method, sample.cov.inv = sample.cov.inv)

    -N*observed
}

# 4b: hessian Mu and vech(Sigma) from samplestats
lav_mvnorm_h1_logl_hessian_samplestats <-
    function(sample.mean    = NULL, # unused!
             sample.cov     = NULL,
             sample.nobs    = NULL,
             Sinv.method    = "eigen",
             sample.cov.inv = NULL) {

    N <- sample.nobs

    # observed information
    observed <- lav_mvnorm_h1_information_observed_samplestats(sample.mean = 
        sample.mean, sample.cov = sample.cov, Sinv.method = Sinv.method, 
        sample.cov.inv = sample.cov.inv)
    
    -N*observed
}



# 5) Information h1 (not expected == observed if data is complete!)

# 5a: unit expected information h1
lav_mvnorm_h1_information_expected <- function(Y              = NULL,
                                               sample.cov     = NULL,
                                               Sinv.method    = "eigen",
                                               sample.cov.inv = NULL) {
    if(is.null(sample.cov.inv)) {

        if(is.null(sample.cov)) {
            # sample statistics
            sample.mean <- colMeans(Y); N <- NROW(Y)
            sample.cov <- 1/N*crossprod(Y) - tcrossprod(sample.mean)
        }

        # invert sample.cov
        sample.cov.inv <- lav_matrix_symmetric_inverse(S = sample.cov, 
                              logdet = FALSE, Sinv.method = Sinv.method)
    }

    I11 <- sample.cov.inv
    I22 <- 0.5 * lav_matrix_duplication_pre_post(sample.cov.inv %x% 
                                                 sample.cov.inv)

    lav_matrix_bdiag(I11, I22)
}

# 5b: unit observed information h1
lav_mvnorm_h1_information_observed_data <- function(Y              = NULL,
                                                    Sinv.method    = "eigen",
                                                    sample.cov.inv = NULL) {

    lav_mvnorm_h1_information_expected(Y = Y, Sinv.method = Sinv.method,
                                       sample.cov.inv = sample.cov.inv)
}

# 5b-bis: observed information h1 from sample statistics
lav_mvnorm_h1_information_observed_samplestats <-
    function(sample.mean    = NULL, # unused!
             sample.cov     = NULL, 
             Sinv.method    = "eigen",
             sample.cov.inv = NULL) {

    if(is.null(sample.cov.inv)) {
        # invert sample.cov
        sample.cov.inv <- lav_matrix_symmetric_inverse(S = sample.cov, 
                              logdet = FALSE, Sinv.method = Sinv.method)
    }

    I11 <- sample.cov.inv
    I22 <- 0.5 * lav_matrix_duplication_pre_post(sample.cov.inv %x% 
                                                 sample.cov.inv)

    lav_matrix_bdiag(I11, I22)
}

# 5c: unit first-order information h1
#     note: first order information h1 == A1 %*% Gamma %*% A1 
#           (where A1 = obs/exp information h1)
lav_mvnorm_h1_information_firstorder <- function(Y              = NULL,
                                                 sample.cov     = NULL,
                                                 Sinv.method    = "eigen",
                                                 sample.cov.inv = NULL,
                                                 Gamma          = NULL) {
    # Gamma
    if(is.null(Gamma)) {
        Gamma <- lav_samplestats_Gamma(Y, meanstructure = TRUE)
    }

    # sample.cov.in
    if(is.null(sample.cov.inv)) {
        # invert sample.cov
        sample.cov.inv <- lav_matrix_symmetric_inverse(S = sample.cov,
                              logdet = FALSE, Sinv.method = Sinv.method)
    }

    # A1
    A1 <- lav_mvnorm_h1_information_expected(Y = Y, Sinv.method = Sinv.method,
                                             sample.cov.inv = sample.cov.inv)

    A1 %*% Gamma %*% A1
}

# 6) inverted information h1 mu + vech(Sigma)

#    6a: (unit) inverted expected information (A1.inv = Gamma.NT)
#    6b: (unit) inverted observed information (A1.inv = Gamma.NT)

lav_mvnorm_h1_inverted_information_expected <- 
lav_mvnorm_h1_inverted_information_observed <- function(Y              = NULL,
                                                        sample.cov     = NULL) {
    # sample.cov
    if(is.null(sample.cov)) {
        sample.mean <- colMeans(Y); N <- NROW(Y)
        sample.cov <- 1/N*crossprod(Y) - tcrossprod(sample.mean)
    }

    I11 <- sample.cov
    I22 <- 2 * lav_matrix_duplication_ginv_pre_post(sample.cov %x% sample.cov)

    Gamma.NT <- lav_matrix_bdiag(I11, I22)

    Gamma.NT
}

#    6c: (unit) inverted first-order information (B1.inv)

lav_mvnorm_h1_inverted_information_firstorder <- function(Y          = NULL,
                                                      sample.cov     = NULL,
                                                      Sinv.method    = "eigen",
                                                      sample.cov.inv = NULL,
                                                      Gamma          = NULL) {
    # Gamma
    if(is.null(Gamma)) {
        Gamma <- lav_samplestats_Gamma(Y, meanstructure = TRUE)
    }

    # Gamma.NT
    Gamma.NT <- 
        lav_mvnorm_h1_inverted_information_expected(Y = Y, 
                                                    sample.cov = sample.cov)

    Gamma.NT %*% solve(Gamma, Gamma.NT)
}


# 7) ACOV h1 mu + vech(Sigma)

#    7a: 1/N * Gamma.NT
#    7b: 1/N * Gamma.NT
lav_mvnorm_h1_acov_expected <-
lav_mvnorm_h1_acov_observed <- function(Y              = NULL,
                                        sample.cov     = NULL) {
    N <- NROW(Y)

    Gamma.NT <- 
        lav_mvnorm_h1_inverted_information_expected(Y = Y, 
                                                    sample.cov = sample.cov)

    (1/N) * Gamma.NT
}

#    7c: 1/N * (Gamma.NT * Gamma^{-1} * Gamma.NT)
lav_mvnorm_h1_acov_firstorder <- function(Y              = NULL,
                                          sample.cov     = NULL,
                                          Sinv.method    = "eigen",
                                          sample.cov.inv = NULL,
                                          Gamma          = NULL) {
    N <- NROW(Y)

    J1.inv <- lav_mvnorm_h1_inverted_information_firstorder(Y = Y,
                  sample.cov = sample.cov, Sinv.method = Sinv.method, 
                  sample.cov.inv = sample.cov.inv, Gamma = Gamma)

    (1/N) * J1.inv
}

#    7d: 1/N * Gamma (sandwich)
lav_mvnorm_h1_acov_sandwich <- function(Y              = NULL,
                                        sample.cov     = NULL,
                                        Gamma          = NULL) {
    N <- NROW(Y)

    # Gamma
    if(is.null(Gamma)) {
        Gamma <- lav_samplestats_Gamma(Y, meanstructure = TRUE)
    }

    (1/N) * Gamma
}

